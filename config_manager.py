#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Gestor de Configuración para Servidor Minecraft
==============================================

Este módulo permite gestionar las configuraciones del servidor de Minecraft.
Proporciona funciones para leer y modificar el archivo server.properties,
así como otras configuraciones importantes del servidor.
"""

import os
import logging
import re
from datetime import datetime

# Configuración del logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("minecraft_config_manager.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ConfigManager")

# Ruta del archivo de propiedades
SERVER_PROPERTIES_FILE = "server.properties"

class ConfigManager:
    """Clase para gestionar la configuración del servidor de Minecraft."""
    
    def __init__(self, server_dir="."):
        """
        Inicializa el gestor de configuración.
        
        Args:
            server_dir (str): Directorio donde se encuentran los archivos del servidor.
        """
        self.server_dir = server_dir
        self.properties_path = os.path.join(server_dir, SERVER_PROPERTIES_FILE)
        self.properties = {}
        self.load_properties()
    
    def load_properties(self):
        """
        Carga las propiedades del servidor desde el archivo server.properties.
        
        Returns:
            dict: Diccionario con las propiedades del servidor.
        """
        self.properties = {}
        
        try:
            if os.path.exists(self.properties_path):
                with open(self.properties_path, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        # Ignorar líneas vacías y comentarios
                        if not line or line.startswith('#'):
                            continue
                        
                        # Dividir la línea en clave y valor
                        if '=' in line:
                            key, value = line.split('=', 1)
                            self.properties[key.strip()] = value.strip()
                
                logger.info(f"Propiedades cargadas desde {self.properties_path}")
            else:
                logger.warning(f"No se encontró el archivo {self.properties_path}")
                
            return self.properties
                
        except Exception as e:
            logger.error(f"Error al cargar propiedades: {e}")
            return {}
    
    def save_properties(self):
        """
        Guarda las propiedades del servidor en el archivo server.properties.
        
        Returns:
            bool: True si se guardó correctamente, False en caso contrario.
        """
        try:
            # Hacer una copia de seguridad del archivo original
            if os.path.exists(self.properties_path):
                backup_path = f"{self.properties_path}.{datetime.now().strftime('%Y%m%d%H%M%S')}"
                with open(self.properties_path, 'r', encoding='utf-8') as src:
                    with open(backup_path, 'w', encoding='utf-8') as dst:
                        dst.write(src.read())
                logger.info(f"Copia de seguridad creada en {backup_path}")
            
            # Guardar las propiedades actualizadas
            with open(self.properties_path, 'w', encoding='utf-8') as f:
                f.write(f"#Minecraft server properties\n")
                f.write(f"#Generated by ConfigManager on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                
                for key, value in sorted(self.properties.items()):
                    f.write(f"{key}={value}\n")
            
            logger.info(f"Propiedades guardadas en {self.properties_path}")
            return True
            
        except Exception as e:
            logger.error(f"Error al guardar propiedades: {e}")
            return False
    
    def get_property(self, key, default=None):
        """
        Obtiene el valor de una propiedad.
        
        Args:
            key (str): Nombre de la propiedad.
            default: Valor por defecto si la propiedad no existe.
            
        Returns:
            str: Valor de la propiedad, o el valor por defecto si no existe.
        """
        return self.properties.get(key, default)
    
    def set_property(self, key, value):
        """
        Establece el valor de una propiedad.
        
        Args:
            key (str): Nombre de la propiedad.
            value: Valor a establecer.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        try:
            # Convertir el valor a string si no lo es
            if value is not None:
                value = str(value)
            
            # Actualizar la propiedad
            self.properties[key] = value
            logger.info(f"Propiedad {key} establecida a {value}")
            return True
            
        except Exception as e:
            logger.error(f"Error al establecer propiedad {key}: {e}")
            return False
    
    def get_server_port(self):
        """
        Obtiene el puerto del servidor.
        
        Returns:
            int: Puerto del servidor, o 25565 por defecto.
        """
        try:
            port = self.get_property("server-port", "25565")
            return int(port)
        except (ValueError, TypeError):
            return 25565
    
    def set_server_port(self, port):
        """
        Establece el puerto del servidor.
        
        Args:
            port (int): Puerto a establecer.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        try:
            port = int(port)
            if port < 1 or port > 65535:
                logger.error(f"Puerto inválido: {port}. Debe estar entre 1 y 65535.")
                return False
            
            return self.set_property("server-port", str(port))
            
        except (ValueError, TypeError):
            logger.error(f"Puerto inválido: {port}. Debe ser un número entero.")
            return False
    
    def get_gamemode(self):
        """
        Obtiene el modo de juego del servidor.
        
        Returns:
            str: Modo de juego ("survival", "creative", "adventure", "spectator").
        """
        return self.get_property("gamemode", "survival")
    
    def set_gamemode(self, gamemode):
        """
        Establece el modo de juego del servidor.
        
        Args:
            gamemode (str): Modo de juego a establecer.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        valid_modes = ["survival", "creative", "adventure", "spectator"]
        gamemode = gamemode.lower()
        
        if gamemode not in valid_modes:
            logger.error(f"Modo de juego inválido: {gamemode}. Debe ser uno de {valid_modes}.")
            return False
        
        return self.set_property("gamemode", gamemode)
    
    def get_difficulty(self):
        """
        Obtiene la dificultad del servidor.
        
        Returns:
            str: Dificultad ("peaceful", "easy", "normal", "hard").
        """
        return self.get_property("difficulty", "easy")
    
    def set_difficulty(self, difficulty):
        """
        Establece la dificultad del servidor.
        
        Args:
            difficulty (str): Dificultad a establecer.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        valid_difficulties = ["peaceful", "easy", "normal", "hard"]
        difficulty = difficulty.lower()
        
        if difficulty not in valid_difficulties:
            logger.error(f"Dificultad inválida: {difficulty}. Debe ser una de {valid_difficulties}.")
            return False
        
        return self.set_property("difficulty", difficulty)
    
    def get_max_players(self):
        """
        Obtiene el número máximo de jugadores permitidos.
        
        Returns:
            int: Número máximo de jugadores, o 20 por defecto.
        """
        try:
            max_players = self.get_property("max-players", "20")
            return int(max_players)
        except (ValueError, TypeError):
            return 20
    
    def set_max_players(self, max_players):
        """
        Establece el número máximo de jugadores permitidos.
        
        Args:
            max_players (int): Número máximo de jugadores.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        try:
            max_players = int(max_players)
            if max_players < 1:
                logger.error(f"Número máximo de jugadores inválido: {max_players}. Debe ser al menos 1.")
                return False
            
            return self.set_property("max-players", str(max_players))
            
        except (ValueError, TypeError):
            logger.error(f"Número máximo de jugadores inválido: {max_players}. Debe ser un número entero.")
            return False
    
    def is_whitelist_enabled(self):
        """
        Verifica si la whitelist está habilitada.
        
        Returns:
            bool: True si la whitelist está habilitada, False en caso contrario.
        """
        return self.get_property("white-list", "false").lower() == "true"
    
    def set_whitelist_enabled(self, enabled):
        """
        Habilita o deshabilita la whitelist.
        
        Args:
            enabled (bool): True para habilitar, False para deshabilitar.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        value = "true" if enabled else "false"
        return self.set_property("white-list", value)
    
    def is_pvp_enabled(self):
        """
        Verifica si el PvP está habilitado.
        
        Returns:
            bool: True si el PvP está habilitado, False en caso contrario.
        """
        return self.get_property("pvp", "true").lower() == "true"
    
    def set_pvp_enabled(self, enabled):
        """
        Habilita o deshabilita el PvP.
        
        Args:
            enabled (bool): True para habilitar, False para deshabilitar.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        value = "true" if enabled else "false"
        return self.set_property("pvp", value)
    
    def get_motd(self):
        """
        Obtiene el mensaje del día (MOTD) del servidor.
        
        Returns:
            str: Mensaje del día.
        """
        return self.get_property("motd", "A Minecraft Server")
    
    def set_motd(self, motd):
        """
        Establece el mensaje del día (MOTD) del servidor.
        
        Args:
            motd (str): Mensaje del día a establecer.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        return self.set_property("motd", motd)
    
    def get_spawn_protection(self):
        """
        Obtiene el radio de protección del spawn.
        
        Returns:
            int: Radio de protección del spawn, o 16 por defecto.
        """
        try:
            spawn_protection = self.get_property("spawn-protection", "16")
            return int(spawn_protection)
        except (ValueError, TypeError):
            return 16
    
    def set_spawn_protection(self, radius):
        """
        Establece el radio de protección del spawn.
        
        Args:
            radius (int): Radio de protección del spawn.
            
        Returns:
            bool: True si se estableció correctamente, False en caso contrario.
        """
        try:
            radius = int(radius)
            if radius < 0:
                logger.error(f"Radio de protección inválido: {radius}. Debe ser al menos 0.")
                return False
            
            return self.set_property("spawn-protection", str(radius))
            
        except (ValueError, TypeError):
            logger.error(f"Radio de protección inválido: {radius}. Debe ser un número entero.")
            return False
    
    def get_all_properties(self):
        """
        Obtiene todas las propiedades del servidor.
        
        Returns:
            dict: Diccionario con todas las propiedades.
        """
        return self.properties.copy()

# Ejemplo de uso
if __name__ == "__main__":
    import argparse
    
    # Crear el parser de argumentos
    parser = argparse.ArgumentParser(description="Gestor de configuración para servidor Minecraft")
    parser.add_argument("accion", choices=["get", "set", "listar"], 
                        help="Acción a realizar")
    parser.add_argument("propiedad", nargs="?", help="Nombre de la propiedad")
    parser.add_argument("valor", nargs="?", help="Valor a establecer")
    
    # Parsear argumentos
    args = parser.parse_args()
    
    # Crear instancia del gestor de configuración
    config_manager = ConfigManager()
    
    # Ejecutar la acción correspondiente
    if args.accion == "listar":
        print("=== Propiedades del servidor ===")
        for key, value in sorted(config_manager.get_all_properties().items()):
            print(f"{key} = {value}")
            
    elif args.accion == "get":
        if not args.propiedad:
            print("Error: Se debe especificar una propiedad.")
            exit(1)
            
        value = config_manager.get_property(args.propiedad)
        if value is not None:
            print(f"{args.propiedad} = {value}")
        else:
            print(f"No se encontró la propiedad: {args.propiedad}")
            
    elif args.accion == "set":
        if not args.propiedad or args.valor is None:
            print("Error: Se debe especificar una propiedad y un valor.")
            exit(1)
            
        if config_manager.set_property(args.propiedad, args.valor):
            config_manager.save_properties()
            print(f"Propiedad {args.propiedad} establecida a {args.valor}.")
        else:
            print(f"Error al establecer la propiedad {args.

